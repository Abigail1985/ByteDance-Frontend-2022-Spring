import { LoaderOptions } from './useLoader';
export declare enum LoaderStatus {
  idle = 0,
  loading = 1,
  fulfilled = 2,
  rejected = 3,
}
export declare type LoaderResult = {
  loading: boolean;
  reloading: boolean;
  data: any;
  error: any;
};
declare const createLoader: (id: string, initialData: Partial<LoaderResult> | undefined, loaderFn: () => Promise<any>, skip?: boolean) => {
  readonly result: {
    loading: boolean;
    reloading: boolean;
    data: any;
    error: any;
  };
  readonly promise: Promise<any> | null;
  onChange: (handler: (status: LoaderStatus, result: LoaderResult) => void) => () => void;
  load: () => Promise<any>;
};
declare type ManagerOption = {
  /**
   * wheather current manage only exec static loader
   */
  skipStatic?: boolean;
  skipNonStatic?: boolean;
};
/**
 * Create loaders manager. It's returned instance will add to context
 * @param initialDataMap used to initialing loader data
 */

export declare const createLoaderManager: (initialDataMap: Record<string, LoaderResult>, managerOptions?: ManagerOption) => {
  hasPendingLoaders: () => boolean;
  awaitPendingLoaders: () => Promise<Record<string, LoaderResult>>;
  add: (loaderFn: () => Promise<any>, loaderOptions: LoaderOptions) => any;
  get: (id: string) => {
    readonly result: {
      loading: boolean;
      reloading: boolean;
      data: any;
      error: any;
    };
    readonly promise: Promise<any> | null;
    onChange: (handler: (status: LoaderStatus, result: LoaderResult) => void) => () => void;
    load: () => Promise<any>;
  } | undefined;
};
export declare type Loader = ReturnType<typeof createLoader>;
export {};