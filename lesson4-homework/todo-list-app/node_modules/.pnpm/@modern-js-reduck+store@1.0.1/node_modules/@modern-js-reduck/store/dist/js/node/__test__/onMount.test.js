"use strict";

var _2 = require("..");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const createCountModel = onMountCreator => (0, _2.model)('count').define((_, {
  onMount,
  use
}) => {
  onMountCreator(onMount, use);
  return {
    state: {
      value: 1
    },
    actions: {
      addValue(state) {
        return _objectSpread(_objectSpread({}, state), {}, {
          value: state.value + 1
        });
      }

    }
  };
});

describe('test onMount hook', () => {
  test('onMount hook should revoked when model mounted', () => {
    const store = (0, _2.createStore)();
    const fn = jest.fn();

    const onMountCreator = onMount => {
      onMount(() => {
        fn();
      });
    };

    const count = createCountModel(onMountCreator);
    store.use(count);
    expect(fn).toBeCalledTimes(1);
  });
  test('onMount hook should revoked only once when store.use model multiple times', () => {
    const store = (0, _2.createStore)();
    const fn = jest.fn();

    const onMountCreator = onMount => {
      onMount(() => {
        fn();
      });
    };

    const count = createCountModel(onMountCreator);
    store.use(count);
    store.use(count);
    store.use(count);
    store.use(count);
    expect(fn).toBeCalledTimes(1);
  });
  test('through `use` to get newest state in onMount', () => {
    const store = (0, _2.createStore)();

    const onMountCreator = (onMount, use) => {
      onMount(() => {
        const [state, actions] = use(count);
        expect(state).toEqual({
          value: 1
        });
        actions.addValue();
        expect(use(count)[0]).toEqual({
          value: 2
        });
      });
    };

    const count = createCountModel(onMountCreator);
    store.use(count);
  });
});