"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.List = void 0;

var _findIndex2 = _interopRequireDefault(require("lodash/findIndex"));

var _isNumber2 = _interopRequireDefault(require("lodash/isNumber"));

var _chalk = _interopRequireDefault(require("chalk"));

var _cliCursor = _interopRequireDefault(require("cli-cursor"));

var _runAsync = _interopRequireDefault(require("run-async"));

var _base = _interopRequireDefault(require("inquirer/lib/prompts/base"));

var _paginator = _interopRequireDefault(require("inquirer/lib/utils/paginator"));

var _events = _interopRequireDefault(require("inquirer/lib/utils/events"));

var _operators = require("rxjs/operators");

var _incrementListIndex = _interopRequireDefault(require("inquirer/lib/utils/incrementListIndex"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class List extends _base.default {
  constructor(question, readLine, answers) {
    super(question, readLine, answers);
    this.paginator = void 0;
    this.firstRender = void 0;
    this.selected = void 0;
    this.done = void 0;

    if (!this.opt.choices) {
      this.throwParamError('choices');
    }

    this.firstRender = true;
    this.selected = 0;
    const def = this.opt.default; // If def is a Number, then use as index. Otherwise, check for value.

    if ((0, _isNumber2.default)(def) && def >= 0 && def < this.opt.choices.realLength) {
      this.selected = def;
    } else if (!(0, _isNumber2.default)(def) && def != null) {
      const index = (0, _findIndex2.default)(this.opt.choices.realChoices, ({
        value
      }) => value === def);
      this.selected = Math.max(index, 0);
    } // Make sure no default is set (so it won't be printed)


    this.opt.default = null;
    const shouldLoop = this.opt.loop === undefined ? true : this.opt.loop; // TODO @types/inquirer Paginator's constructor type is incorrect
    // https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/inquirer/lib/utils/paginator.d.ts

    this.paginator = new _paginator.default(this.screen, {
      isInfinite: shouldLoop
    });
  }

  onUpKey() {
    this.selected = (0, _incrementListIndex.default)(this.selected, 'up', this.opt);
    this.render();
  }

  onDownKey() {
    this.selected = (0, _incrementListIndex.default)(this.selected, 'down', this.opt);
    this.render();
  }

  onNumberKey(input) {
    if ((0, _isNumber2.default)(input) && input <= this.opt.choices.realLength) {
      this.selected = input - 1;
    }

    this.render();
  }

  getCurrentValue() {
    return this.opt.choices.getChoice(this.selected).value;
  }

  onSubmit(value) {
    this.status = 'answered'; // Rerender prompt

    this.render();
    this.screen.done();

    _cliCursor.default.show();

    if (this.done) {
      this.done(value);
    }
  }

  _run(cb) {
    this.done = cb;
    const events = (0, _events.default)(this.rl); // rxjs type is not match inquirer type, so use as any

    events.normalizedUpKey.pipe((0, _operators.takeUntil)(events.line)).forEach(this.onUpKey.bind(this));
    events.normalizedDownKey.pipe((0, _operators.takeUntil)(events.line)).forEach(this.onDownKey.bind(this));
    events.numberKey.pipe((0, _operators.takeUntil)(events.line)).forEach(this.onNumberKey.bind(this));
    events.line.pipe((0, _operators.take)(1), (0, _operators.map)(this.getCurrentValue.bind(this)), (0, _operators.mergeMap)(value => (0, _runAsync.default)(this.opt.filter)(value))).forEach(this.onSubmit.bind(this)); // Init the prompt

    _cliCursor.default.hide();

    this.render();
    return this;
  }

  render() {
    // Render question
    let message = this.getQuestion();

    if (this.firstRender) {
      message += _chalk.default.dim('(Use arrow keys)');
    } // Render choices or answer depending on the state


    if (this.status === 'answered') {
      message += _chalk.default.cyan(this.opt.choices.getChoice(this.selected).short);
    } else {
      const choicesStr = (0, _utils.listRender)(this.opt.choices, this.selected, this.answers);
      const indexPosition = this.opt.choices.indexOf(this.opt.choices.getChoice(this.selected));
      const realIndexPosition = this.opt.choices.choices.reduce((acc, value, i) => {
        // Dont count lines past the choice we are looking at
        if (i > indexPosition) {
          return acc;
        } // Add line if it's a separator


        if (value.type === 'separator') {
          return acc + 1;
        }

        let l = value.name; // Non-strings take up one line

        if (typeof l !== 'string') {
          return acc + 1;
        } // Calculate lines taken up by string


        l = l.split('\n');
        return acc + l.length;
      }, 0) - 1;
      message += `\n${this.paginator.paginate(choicesStr, realIndexPosition)}`;
    }

    this.firstRender = false;
    this.screen.render(message, '');
  }

}

exports.List = List;