"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StatsCache = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _crypto = _interopRequireDefault(require("crypto"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class StatsCache {
  constructor() {
    this.cachedHash = {};
    this.cachedSize = {};
  }

  add(files) {
    const {
      cachedHash,
      cachedSize
    } = this;

    for (const filename of files) {
      if (_fs.default.existsSync(filename)) {
        const stats = _fs.default.statSync(filename);

        if (stats.isFile() && !cachedHash[filename]) {
          cachedHash[filename] = this.hash(stats, filename);
          cachedSize[filename] = stats.size;
        }
      }
    }
  }

  refresh(filename) {
    const {
      cachedHash,
      cachedSize
    } = this;

    if (_fs.default.existsSync(filename)) {
      const stats = _fs.default.statSync(filename);

      if (stats.isFile()) {
        cachedHash[filename] = this.hash(stats, filename);
        cachedSize[filename] = stats.size;
      }
    }
  }

  del(filename) {
    if (this.cachedHash[filename]) {
      delete this.cachedHash[filename];
      delete this.cachedSize[filename];
    }
  }

  isDiff(filename) {
    const {
      cachedHash,
      cachedSize
    } = this;

    const stats = _fs.default.statSync(filename);

    const hash = cachedHash[filename];
    const size = cachedSize[filename];

    if (stats.size !== size) {
      return true;
    }

    if (this.hash(stats, filename) !== hash) {
      return true;
    }

    return false;
  }

  has(filename) {
    return Boolean(this.cachedHash[filename]);
  }

  hash(stats, filename) {
    return _crypto.default.createHash('md5').update(_fs.default.readFileSync(filename)).digest('hex');
  }

}

exports.StatsCache = StatsCache;