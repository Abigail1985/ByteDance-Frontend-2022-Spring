"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRequest = exports.configure = void 0;

var _querystring = _interopRequireDefault(require("querystring"));

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var _pathToRegexp = require("path-to-regexp");

var _node = require("@modern-js/plugin-ssr/node");

var _handleRes = require("./handleRes");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let realRequest;
let realAllowedHeaders = [];

const originFetch = (...params) => (0, _nodeFetch.default)(...params) // eslint-disable-next-line promise/prefer-await-to-then
.then(_handleRes.handleRes);

const configure = options => {
  const {
    request,
    interceptor,
    allowedHeaders
  } = options;
  realRequest = request || originFetch;

  if (interceptor && !request) {
    realRequest = interceptor(_nodeFetch.default);
  }

  if (Array.isArray(allowedHeaders)) {
    realAllowedHeaders = allowedHeaders;
  }
};

exports.configure = configure;

const createRequest = (path, method, port, // 后续可能要修改，暂时先保留
// eslint-disable-next-line @typescript-eslint/no-unused-vars
fetch = _nodeFetch.default) => {
  const getFinalPath = (0, _pathToRegexp.compile)(path, {
    encode: encodeURIComponent
  });
  const keys = [];
  (0, _pathToRegexp.pathToRegexp)(path, keys); // eslint-disable-next-line max-statements

  const sender = (...args) => {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const webRequestHeaders = (0, _node.useHeaders)();
    const payload = typeof args[args.length - 1] === 'object' ? args[args.length - 1] : {};
    payload.params = payload.params || {};
    keys.forEach((key, index) => {
      payload.params[key.name] = args[index];
    });
    const plainPath = getFinalPath(payload.params);
    const finalPath = payload.query ? `${plainPath}?${_querystring.default.stringify(payload.query)}` : plainPath;
    const headers = payload.headers || {};
    let body;

    for (const key of realAllowedHeaders) {
      if (typeof webRequestHeaders[key] !== 'undefined') {
        headers[key] = webRequestHeaders[key];
      }
    }

    if (payload.data) {
      headers['Content-Type'] = 'application/json';
      body = typeof payload.data === 'object' ? JSON.stringify(payload.data) : payload.body;
    } else if (payload.body) {
      headers['Content-Type'] = 'text/plain'; // eslint-disable-next-line prefer-destructuring

      body = payload.body;
    } else if (payload.formData) {
      body = payload.formData; // https://stackoverflow.com/questions/44919424/bad-content-type-header-no-multipart-boundary-nodejs
      // need multipart boundary auto attached by node-fetch when multipart is true
      // headers['Content-Type'] = 'multipart/form-data';
    } else if (payload.formUrlencoded) {
      headers['Content-Type'] = 'application/x-www-form-urlencoded';

      if (typeof payload.formUrlencoded === 'object') {
        body = _querystring.default.stringify(payload.formUrlencoded);
      } else {
        body = payload.formUrlencoded;
      }
    }

    const url = `http://localhost:${port}${finalPath}`;
    const fetcher = realRequest || originFetch;
    return fetcher(url, {
      method,
      body,
      headers
    });
  };

  return sender;
};

exports.createRequest = createRequest;