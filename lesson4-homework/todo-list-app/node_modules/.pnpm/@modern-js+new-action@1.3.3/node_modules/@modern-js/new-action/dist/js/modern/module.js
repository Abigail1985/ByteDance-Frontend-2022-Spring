import _merge from "lodash/merge";
import { CodeSmith, GeneratorCore, MaterialsManager } from '@modern-js/codesmith';
import { AppAPI, forEach } from '@modern-js/codesmith-api-app';
import { i18n, ModuleNewActionSchema, ModuleActionFunctions, ModuleActionFunctionsDependencies, ModuleActionFunctionsDevDependencies, ModuleActionFunctionsPeerDependencies, ModuleActionFunctionsAppendTypeContent, ModuleNewActionGenerators } from '@modern-js/generator-common';
import { getPackageVersion, getPackageManager } from '@modern-js/generator-utils';
import { alreadyRepo, hasEnabledFunction } from "./utils";
// eslint-disable-next-line max-statements
export const ModuleNewAction = async options => {
  const {
    locale = 'zh',
    distTag = '',
    debug = false,
    registry = '',
    config = '{}',
    cwd = process.cwd()
  } = options;
  let UserConfig = {};

  try {
    UserConfig = JSON.parse(config);
  } catch (e) {
    throw new Error('config is not a valid json');
  }

  i18n.changeLanguage({
    locale: UserConfig.locale || locale
  });
  const smith = new CodeSmith({
    debug,
    registryUrl: registry
  });

  if (!alreadyRepo(cwd)) {
    smith.logger.warn('not valid modern.js repo');
  }

  const mockGeneratorCore = new GeneratorCore({
    logger: smith.logger,
    materialsManager: new MaterialsManager(),
    outputPath: ''
  });
  const appAPI = new AppAPI({
    materials: {},
    config: {},
    data: {},
    current: null
  }, mockGeneratorCore);
  let hasOption = false;
  const schema = forEach(ModuleNewActionSchema, schemaItem => {
    if (ModuleActionFunctions.includes(schemaItem.key)) {
      const enable = hasEnabledFunction(schemaItem.key, ModuleActionFunctionsDependencies, ModuleActionFunctionsDevDependencies, ModuleActionFunctionsPeerDependencies, cwd);
      const {
        when
      } = schemaItem;
      schemaItem.when = enable ? () => false : when;

      if (!enable) {
        hasOption = true;
      }
    }
  });

  if (!hasOption) {
    smith.logger.warn('no option can be enabled'); // eslint-disable-next-line no-process-exit

    process.exit(1);
  }

  const ans = await appAPI.getInputBySchema(schema, UserConfig);
  const actionType = ans.actionType;
  const action = ans[actionType];
  let generator = ModuleNewActionGenerators[actionType] && ModuleNewActionGenerators[actionType][action];

  if (!generator) {
    throw new Error(`no valid option`);
  }

  if (distTag) {
    generator = `${generator}@${distTag}`;
  }

  const devDependency = ModuleActionFunctionsDevDependencies[action];
  const dependency = ModuleActionFunctionsDependencies[action];
  const peerDependency = ModuleActionFunctionsPeerDependencies[action];

  const finalConfig = _merge(UserConfig, ans, {
    locale: UserConfig.locale || locale,
    packageManager: UserConfig.packageManager || (await getPackageManager(cwd))
  }, {
    devDependencies: devDependency ? {
      [devDependency]: `^${await getPackageVersion(devDependency)}`
    } : {},
    dependencies: dependency ? {
      [dependency]: `^${await getPackageVersion(dependency)}`
    } : {},
    peerDependencies: peerDependency ? {
      [peerDependency]: `^${await getPackageVersion(peerDependency)}`
    } : {},
    appendTypeContent: ModuleActionFunctionsAppendTypeContent[action]
  });

  const task = [{
    name: generator,
    config: finalConfig
  }];
  await smith.forge({
    tasks: task.map(runner => ({
      generator: runner.name,
      config: runner.config
    })),
    pwd: cwd
  });
};