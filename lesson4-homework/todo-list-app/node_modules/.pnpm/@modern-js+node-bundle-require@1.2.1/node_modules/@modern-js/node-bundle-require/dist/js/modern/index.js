function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import path from 'path';
import { randomUUID } from 'crypto';
import { fs } from '@modern-js/utils';
import { build } from 'esbuild';
const JS_EXT_RE = /\.(mjs|cjs|ts|js|tsx|jsx)$/; // Must not start with "/" or "./" or "../"
// "/test/node_modules/foo"
// "c:/node_modules/foo"

export const EXTERNAL_REGEXP = /^[^./]|^\.[^./]|^\.\.[^/]/;
const CACHE_DIR = path.relative(process.cwd(), './node_modules/.node-bundle-require');

function inferLoader(ext) {
  if (ext === '.mjs' || ext === '.cjs') {
    return 'js';
  }

  return ext.slice(1);
}

const defaultGetOutputFile = filepath => path.resolve(CACHE_DIR, `${filepath}-${Date.now()}.${randomUUID({
  disableEntropyCache: true
})}.bundled.cjs`);

export async function bundleRequire(filepath, options) {
  if (!JS_EXT_RE.test(filepath)) {
    throw new Error(`${filepath} is not a valid JS file`);
  }

  const getOutputFile = (options === null || options === void 0 ? void 0 : options.getOutputFile) || defaultGetOutputFile;
  const outfile = getOutputFile(filepath);
  await build(_objectSpread(_objectSpread({
    entryPoints: [filepath],
    outfile,
    format: 'cjs',
    platform: 'node',
    bundle: true,
    // fix transforming error when the project's tsconfig.json
    // sets `target: "es5"`
    // reference: https://github.com/evanw/esbuild/releases/tag/v0.12.6
    target: 'esnext'
  }, options === null || options === void 0 ? void 0 : options.esbuildOptions), {}, {
    plugins: [...((options === null || options === void 0 ? void 0 : options.esbuildPlugins) || []), // https://github.com/evanw/esbuild/issues/1051#issuecomment-806325487
    {
      name: 'native-node-modules',

      // eslint-disable-next-line @typescript-eslint/no-shadow
      setup(build) {
        // If a ".node" file is imported within a module in the "file" namespace, resolve
        // it to an absolute path and put it into the "node-file" virtual namespace.
        build.onResolve({
          filter: /\.node$/,
          namespace: 'file'
        }, args => ({
          path: require.resolve(args.path, {
            paths: [args.resolveDir]
          }),
          namespace: 'node-file'
        })); // Files in the "node-file" virtual namespace call "require()" on the
        // path from esbuild of the ".node" file in the output directory.

        build.onLoad({
          filter: /.*/,
          namespace: 'node-file'
        }, args => ({
          contents: `
              import path from ${JSON.stringify(args.path)}
              try { module.exports = require(path) }
              catch {}
            `
        })); // If a ".node" file is imported within a module in the "node-file" namespace, put
        // it in the "file" namespace where esbuild's default loading behavior will handle
        // it. It is already an absolute path since we resolved it to one above.

        build.onResolve({
          filter: /\.node$/,
          namespace: 'node-file'
        }, args => ({
          path: args.path,
          namespace: 'file'
        })); // Tell esbuild's default loading behavior to use the "file" loader for
        // these ".node" files.

        const opts = build.initialOptions;
        opts.loader = opts.loader || {};
        opts.loader['.node'] = 'file';
      }

    }, {
      name: 'replace-path',

      setup(ctx) {
        ctx.onLoad({
          filter: JS_EXT_RE
        }, async args => {
          const contents = fs.readFileSync(args.path, 'utf-8');
          return {
            contents: contents.replace(/\b__filename\b/g, JSON.stringify(args.path)).replace(/\b__dirname\b/g, JSON.stringify(path.dirname(args.path))).replace(/\bimport\.meta\.url\b/g, JSON.stringify(`file://${args.path}`)),
            loader: inferLoader(path.extname(args.path))
          };
        });
      }

    }, // https://github.com/evanw/esbuild/issues/619#issuecomment-751995294
    {
      name: 'make-all-packages-external',

      setup(_build) {
        _build.onResolve({
          filter: EXTERNAL_REGEXP
        }, args => {
          let external = true; // FIXME: windows external entrypoint

          if (args.kind === 'entry-point') {
            external = false;
          }

          return {
            path: args.path,
            external
          };
        });
      }

    }]
  }));
  let mod;
  const req = (options === null || options === void 0 ? void 0 : options.require) || require;

  try {
    mod = await req(outfile);
  } finally {
    // Remove the outfile after executed
    fs.unlinkSync(outfile);
  }

  return mod;
}