function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { compatRequire } from '@modern-js/utils';
import { match } from 'path-to-regexp';
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const VALID_METHODS = ['get', 'post', 'put', 'delete', 'patch']; // eslint-disable-next-line @typescript-eslint/no-unused-vars

const BODY_PARSED_METHODS = ['post', 'put', 'delete', 'patch'];

const createFunctionDataHandler = (method, handler) => async (context, next) => {
  const {
    req,
    res
  } = context;
  return handler(req, res, next);
};

const createStaticDataHandler = (method, handler) => context => {
  const {
    res
  } = context;
  res.setHeader('Content-Type', 'application/json');
  res.end(JSON.stringify(handler));
};

const allowTypes = ['object', 'function'];

const normalizeConfig = mockConfig => Object.keys(mockConfig).reduce((acc, key) => {
  const handler = mockConfig[key];
  const type = typeof handler;

  if (!allowTypes.includes(type)) {
    throw new Error(`mock value of ${key} should be object or function, but got ${type}`);
  }

  const meta = parseKey(key);

  if (type === 'object') {
    acc.push(_objectSpread(_objectSpread({}, meta), {}, {
      handler: createStaticDataHandler(meta.method, handler)
    }));
  } else {
    acc.push(_objectSpread(_objectSpread({}, meta), {}, {
      handler: createFunctionDataHandler(meta.method, handler)
    }));
  }

  return acc;
}, []);

const _blank = ' ';

const parseKey = key => {
  // 'Method /pathname' | '/pathname'
  const splited = key.split(_blank).filter(Boolean);

  if (splited.length > 1) {
    const [method, pathname] = splited;
    return {
      method: method.toLowerCase(),
      path: pathname
    };
  } // default return get method


  return {
    method: 'get',
    path: key
  };
};

export default (filepath => {
  const mockModule = compatRequire(filepath);

  if (!mockModule) {
    throw new Error(`Mock file ${filepath} parsed failed!`);
  }

  const data = normalizeConfig(mockModule);
  return data;
});
export const getMatched = (context, mockApiList) => {
  const {
    path: targetPathname,
    method: targetMethod
  } = context;
  const matched = mockApiList.find(mockApi => {
    const {
      method,
      path: pathname
    } = mockApi;

    if (method.toLowerCase() === targetMethod.toLowerCase()) {
      return match(pathname, {
        encode: encodeURI,
        decode: decodeURIComponent
      })(targetPathname);
    }

    return false;
  });
  return matched;
};