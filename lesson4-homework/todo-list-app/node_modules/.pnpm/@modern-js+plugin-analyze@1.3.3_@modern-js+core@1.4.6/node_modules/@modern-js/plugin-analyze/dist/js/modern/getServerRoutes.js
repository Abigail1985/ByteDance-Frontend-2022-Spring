const _excluded = ["path"],
      _excluded2 = ["path"];

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import path from 'path';
import fs from 'fs';
import urlJoin from 'url-join';
import { isPlainObject, removeLeadingSlash, getEntryOptions, SERVER_BUNDLE_DIRECTORY, MAIN_ENTRY_NAME, removeTailSlash } from '@modern-js/utils';
import { walkDirectory } from "./utils";
/**
 * Add base url for each server route.
 * @param baseUrl - Base url from server.baseUrl
 * @param routes - Server routes.
 * @returns Server routes with baseUrl prefixed.
 */

const applyBaseUrl = (baseUrl, routes) => {
  if (baseUrl) {
    if (Array.isArray(baseUrl)) {
      return baseUrl.reduce((previous, current) => [...previous, ...applyBaseUrl(current, routes)], []);
    } else {
      return routes.map(route => {
        const urlPath = urlJoin(baseUrl, route.urlPath);
        return _objectSpread(_objectSpread({}, route), {}, {
          urlPath: urlPath === '/' ? urlPath : removeTailSlash(urlPath)
        });
      });
    }
  }

  return routes;
};
/**
 *
 * @param original - Original entrypoint route info.
 * @param routeOptions - Custom entrypoint route config from server.routes.
 * @returns
 */


const applyRouteOptions = (original, routeOptions) => {
  const {
    route,
    disableSpa
  } = routeOptions;
  original.isSPA = !disableSpa; // set entryPath as dir

  !original.isSPA && (original.entryPath = path.dirname(original.entryPath));
  let routes;

  if (route) {
    if (Array.isArray(route)) {
      routes = route.map(url => {
        if (isPlainObject(url)) {
          const _ref = url,
                {
            path: urlPath
          } = _ref,
                other = _objectWithoutProperties(_ref, _excluded);

          return _objectSpread(_objectSpread(_objectSpread({}, original), other), {}, {
            urlPath
          });
        } else {
          return _objectSpread(_objectSpread({}, original), {}, {
            urlPath: url
          });
        }
      });
    } else if (isPlainObject(route)) {
      const _ref2 = route,
            {
        path: urlPath
      } = _ref2,
            other = _objectWithoutProperties(_ref2, _excluded2);

      routes = [_objectSpread(_objectSpread(_objectSpread({}, original), other), {}, {
        urlPath
      })];
    } else {
      routes = [_objectSpread(_objectSpread({}, original), {}, {
        urlPath: route
      })];
    }
  } else {
    routes = [original];
  }

  return routes;
};
/**
 * Collect routes from entrypoints.
 * @param entrypoints - Bundle entrypoints.
 * @param config - Normalized user config.
 * @returns entrypoint Routes
 */


const collectHtmlRoutes = (entrypoints, appContext, config) => {
  const {
    output: {
      htmlPath,
      disableHtmlFolder,
      enableModernMode
    },
    server: {
      baseUrl,
      routes,
      ssr,
      ssrByEntries
    }
  } = config;
  const {
    packageName
  } = appContext;
  let htmlRoutes = entrypoints.reduce((previous, {
    entryName
  }) => {
    const isSSR = Boolean(getEntryOptions(entryName, ssr, ssrByEntries, packageName));
    let route = {
      urlPath: `/${entryName === MAIN_ENTRY_NAME ? '' : entryName}`,
      entryName,
      entryPath: removeLeadingSlash(path.posix.normalize(`${htmlPath}/${entryName}${disableHtmlFolder ? '.html' : '/index.html'}`)),
      isSPA: true,
      isSSR,
      enableModernMode: Boolean(enableModernMode),
      bundle: isSSR ? `${SERVER_BUNDLE_DIRECTORY}/${entryName}.js` : undefined
    };

    if (routes !== null && routes !== void 0 && routes.hasOwnProperty(entryName)) {
      const routeOptions = isPlainObject(routes[entryName]) ? routes[entryName] : {
        route: routes[entryName]
      };
      route = applyRouteOptions(route, routeOptions);
    }

    return Array.isArray(route) ? [...previous, ...route] : [...previous, route];
  }, []);
  htmlRoutes = applyBaseUrl(baseUrl, htmlRoutes);
  return htmlRoutes;
};
/**
 * Collect static public file routes from config/public folder.
 * @param appContext - App context info.
 * @param config - normalized user config.
 * @returns Static public file routes.
 */


const collectStaticRoutes = (appContext, config) => {
  const {
    appDirectory
  } = appContext;
  const {
    source: {
      configDir
    },
    server: {
      publicRoutes = {}
    }
  } = config;
  const publicFolder = path.resolve(appDirectory, configDir, 'public');
  return fs.existsSync(publicFolder) ? walkDirectory(publicFolder).map(filePath => {
    const urlPath = `${urlJoin(toPosix(filePath).slice(toPosix(publicFolder).length))}`;
    return {
      urlPath: publicRoutes[removeLeadingSlash(urlPath)] || urlPath,
      isSPA: true,
      isSSR: false,
      entryPath: toPosix(path.relative(path.resolve(appDirectory, configDir), filePath))
    };
  }) : [];
};

export const getServerRoutes = (entrypoints, {
  appContext,
  config
}) => [...collectHtmlRoutes(entrypoints, appContext, config), ...collectStaticRoutes(appContext, config)];

const toPosix = pathStr => pathStr.split(path.sep).join(path.posix.sep);